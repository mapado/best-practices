---
title: Traductions
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

### Cl√© de traduction

La cl√© de traduction NE DOIT PAS √™tre cr√©√©e √† partir de variable dans une chaine de caract√®re.

Elle doit TOUJOURS √™tre une chaine de caract√®re statique.

<Tabs
  defaultValue="good"
  values={[
    { label: 'Pas bien üëé', value: 'bad', },
    { label: 'Bien üëç', value: 'good', },
  ]}
>
<TabItem value="bad">

```ts
t(`errors.${errorCode}`);
```

</TabItem>
<TabItem value="good">

```ts
t('errors.network');
```

</TabItem>
</Tabs>

:::info Pourquoi ?

### Exp√©rience de d√©veloppement

On a souvent besoin de chercher dans la base de code o√π se trouve une cl√© de traduction sp√©cifique.

### Analyse statique

Les outils d'analyse statique (comme [i18next-scanner](https://github.com/i18next/i18next-scanner)) peuvent √™tre utilis√©s pour d√©tecter les cl√©s de traduction manquantes ou inutilis√©es dans le code.

Id√©alement, ou pourrait aussi valider avec TypeScript que la cl√© de traduction existe bien dans les fichiers de traduction.

:::

Si l'on a besoin d'avoir une partie dynamique dans la cl√© de traduction, il existe des fa√ßons de faire :

#### Utiliser un "switch ICU"

```ts
return t('errors', { errorCode });
```

et dans l'√©diteur de traduction:

```json
{errorCode, select,
  network {Erreur r√©seau}
  server {Erreur serveur}
  timeout {D√©lai d'attente d√©pass√©}
  other {Erreur inconnue}
}
```

#### Utiliser un "switch"

```ts
switch (errorCode) {
  case 'network':
    return t('errors.network');
    break;
  case 'server':
    return t('errors.server');
    break;
  case 'timeout':
    return t('errors.timeout');
    break;
  default:
    return t('errors.unknown');
}
```
