---
title: Guide de style
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

## Comment est-ce qu'on √©crit une fonction (arrow function vs function declaration)

Javascript permet la d√©finition de "arrow functions". Bien qu'ayant des [diff√©rences non n√©gligeables](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) avec leurs cons≈ìurs, on utilise l'une ou l'autre syntaxe en fonction des pr√©f√©rences personnelles.

On DEVRAIT utiliser la d√©claration de fonction **seulement** dans le cas o√π la fonction est au premier niveau (comme souvent avec les utils ou les composants) :

:::caution Attention
On ne DEVRAIT jamais avoir de d√©claration de fonction dans une d√©claration de fonction ! Une fois la d√©claration de fonction faite au premier niveau, les fonctions qu'elle contient DEVRAIENT √™tre des "arrow functions".
:::

<Tabs
  defaultValue="good"
  values={[
    { label: 'Pas bien üëé', value: 'bad', },
    { label: 'Bien üëç', value: 'good', },
  ]}
>
  <TabItem value="bad">

```jsx title="/src/utils/foo.js"
function foo(callback) {
  const value = callback();

  function getUser() {
    // Do something
  }

  if (value === true) {
    getUser();
  }
}
```

```jsx title="/src/components/Content.js"
function Content() {
  function handleClick() {
    // Do something
  }

  return <button onClick={handleClick}>DO NOT PRESS</button>;
}
```

  </TabItem>
  <TabItem value="good">

```jsx title="/src/utils/foo.js"
function foo(callback) {
  const value = callback();
  const getUser = () => {
    // Do something
  };

  if (value === true) {
    getUser();
  }
}
```

```jsx title="/src/components/Content.js"
function Content() {
  const handleClick = () => {
    // Do something
  };

  return <button onClick={handleClick}>DO NOT PRESS</button>;
}
```

  </TabItem>
</Tabs>

On DEVRAIT utiliser les "arrow functions" dans tous les autres cas :

- Dans des "callback" :

```jsx
list
  .map((entity) => entity.id)
  .filter((id) => id > 5)
  .some((id) => id % 2 === 0);

<button onClick={() => setVisible(true)}>show</button>;
```

- Si sa d√©finition ne fait qu'une seule ligne, avec un seul retour possible :

```js
const isValid = (entity) => entity.itemList.some((item) => item.isValid);
```

:::note √Ä lire aussi
Le guide JavaScript de AirBnB [sur les arrow functions](https://github.com/airbnb/javascript#arrow-functions) donne des informations int√©ressantes sur la fa√ßon d'utiliser les arrow functions. Ils d√©finissent pour leur part les cas suivants:

> Lorsque vous devez utiliser des fonctions anonymes (comme pour passer une fonction de retour en-ligne), utilisez la notation "arrow-function"
>
> Pourquoi ? Cela cr√©e une version de la fonction qui s'execute dans le contexte actuel (this), qui est habituellement ce que l'on souhaite, et la syntaxe est plus concise.

:::

## Constantes & Enums

On DEVRAIT utiliser des constantes lorsqu'on utilise une donn√©e simple (`string` | `number` | `boolean`...) en tant que valeur de configuration (d'une fonction ou autre).

```jsx
const TIMEOUT_DELAY = 1000;

setTimeout(doSomething, TIMEOUT_DELAY);
```

```jsx
const EVENT_DATE_BY_LIST = "list";
const EVENT_DATE_BY_DATE = "date";
// ...
const [selectedTab, setSelectedTab] = useState(EVENT_DATE_BY_LIST);
```

Dans le cas o√π plusieurs constantes sont utilis√©es √† plusieurs endroits, on privil√©giera de les regrouper sous un [enum TypeScript](https://www.typescriptlang.org/docs/handbook/enums.html). Cela rend √©galement le typage beaucoup plus simple.

```tsx
export enum MODULE_TYPE {
  INFORMATION = "information",
  RECOMMENDATION = "recommendation",
  PROMOTE = "promote",
}

function generateModule(moduleType: MODULE_TYPE) {
  if (moduleType === MODULE_TYPE.INFORMATION) {
    // do something
  }

  // do something else
}
```

:::caution Attention
On **DEVRAIT toujours assigner une valeur** √† la cl√© de l'enum afin d'√©viter des effets ind√©sirables (voir pourquoi dans [cet article (En)](https://blog.beraliv.dev/2022-09-10-with-or-without-enums#numeric-enums-are-not-type-safe)).
:::

:::info Convention
On DEVRAIT √©crire les constantes de configuration et enums en MAJUSCULE.
:::

## Espacements entre les types de d√©clarations

Afin de gagner en lisibilit√© dans la lecture du code, on DOIT ajouter une ligne vide au-dessus d'un type de d√©claration quand le pr√©c√©dent est diff√©rent.

```jsx
function Foo() {
  const { t } = useTranslation();
  const [loading, setLoading] = useState(true);
  let name = "JD";

  if (!loading) {
    name = "Chris";
  }

  useEffect(() => {
    const timeout = setTimeout(() => setLoading(false), 500);

    return () => clearTimeout(timeout);
  }, []);

  if (loading) {
    return <MpdLoader />;
  }

  return <div>{t("hello", { name })}</div>;
}
```

Dans l'exemple ci-dessus, on remarque la construction suivante :

- Un espace est pr√©sent entre les variables et le `if` ;
- Un espace est pr√©sent entre le `if` et le `useEffect` ;
- √Ä l'int√©rieur du `useEffect`, un espace est pr√©sent entre la variable et le `return` ;
- Un espace est pr√©sent entre le `useEffect` et le `if` ;
- Le `return` dans le `if` n'a pas d'espacement car il est tout seul ;
- Un espace est pr√©sent entre le `if` et le `return` ;

:::info Eslint
La r√®gle eslint [padding-line-between-statements](https://eslint.org/docs/latest/rules/padding-line-between-statements) est disponible sur les projets pour d√©tecter une erreur si ce sch√©ma n'est pas respect√©.
:::

### "Array destructuring"

On **DEVRAIT** utiliser le "array destructuring" quand on affecte des variables

```tsx
const [counter, setCounter] = useState(0);
```

On ne **DEVRAIT PAS** utiliser le array destructuring si l'on n'a pas les mots cl√©s `const` ou `let` devant le tableau.

```tsx
let counter = 0;

[counter] = generateCounter();
```

:::info Eslint
**Pourquoi ?**

Cette syntaxe est difficilement compr√©hensible car on ne comprends pas directement que l'on est en train d'affecter des variables (on dirait que l'on cr√©e un tableau).
:::
